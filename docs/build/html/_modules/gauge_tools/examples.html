
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>gauge_tools.examples &#8212; gauge_tools 0.0.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for gauge_tools.examples</h1><div class="highlight"><pre>
<span></span><span class="c1"># Created by Javad Komijani, University of Tehran, 24/Apr/2020.</span>
<span class="c1"># Copyright (C) 2020 Javad Komijani</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License &lt;https://www.gnu.org/licenses/&gt;</span>
<span class="c1"># for more deteils.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains examples that correspond to the exercises suggested in these `lecture notes`_.</span>
<span class="sd">.. _lecture notes: https://arxiv.org/abs/hep-lat/0506036v1</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rc</span>
    <span class="n">rc</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">PLOTS</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">PLOTS</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot generate plots because matplolib did not get imported correctly&quot;</span><span class="p">)</span>

<span class="c1">#==========================================================</span>
<span class="c1">#==========================================================</span>
<span class="c1"># Example 1:: </span>
<span class="c1">#   Generate gauge configurations and compute Wilson loops.</span>
<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">generate_ensemble</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">beta</span><span class="o">=</span><span class="mf">5.5</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_therm</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">n_cfgs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_skip</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">eps_hit</span><span class="o">=</span><span class="mf">0.24</span><span class="p">,</span>
        <span class="n">update_u0</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates a new ensemble of gauge configurations.</span>
<span class="sd">    </span>
<span class="sd">    The default values of the parameters correspond to the exercise on page 35 of the `lecture notes`_.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list`` ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``action``    (str):      `&#39;W&#39;` stands for Wilson action and `&#39;imp&#39;` stand for an improved action.</span>
<span class="sd">        - ``beta``      (float):    the lattice beta; with our convension this beta already contains the tadpole improvement factor.</span>
<span class="sd">        - ``u0``        (float):    the `u0` used for tadpole improvement (irrelevant for the non-improved action).</span>
<span class="sd">        - ``n_therm``   (int):      number of sweeps for thermalizing the gauge configurations.</span>
<span class="sd">        - ``n_cfgs``    (int):      number of gauge configurations requested to be generated and saved.</span>
<span class="sd">        - ``n_skip``    (int):      number of sweeps between two saved configurations.</span>
<span class="sd">        - ``update_u0`` (bool):     if `True` updates the value of `u0` in the process of thermalizing.</span>
<span class="sd">        - ``ens_tag``   (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                                    this tag is used to automatically create a file name for saving (loading) a gauge configuration;\</span>
<span class="sd">                                    `fname = &quot;{}{}.npy&quot;.format(ens_tag, ind_cfg)`, where `ind_cfg` is explained below.</span>

<span class="sd">    A note on `ind_cfg`:</span>
<span class="sd">        this index counts the number of all sweeps including the sweeps for thermalization. With the default values\</span>
<span class="sd">        of the parameters of this function we will have `ind_cfg \in [100,150,200,250,300]`</span>
<span class="sd">        for 5 gauge configurations that are going to be saved. (`ind_cfg` is nothing but `sweep_cntr` in the code.) </span>

<span class="sd">    Usage:</span>
<span class="sd">        (1) For generating 5 gauge configurations with Wilson action, one can simply use::</span>

<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.generate_ensemble(n_cfgs=5, ens_tag=&#39;W_&#39;)</span>

<span class="sd">            This generates 5 gauge configurations and saves each of them to a seperate file in the current directory.</span>
<span class="sd">            One can of course change default values of the parameters of the function.</span>

<span class="sd">        (2) For generating 5 gauge configurations with the improved action, one can change the parameters to something like::</span>

<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.generate_ensemble(beta=1.719/0.797**4, u0=0.797, n_cfgs=5, ens_tag=&#39;imp_&#39;)</span>

<span class="sd">        (3) One can also let the code dynamically determine the value of `u0`. To this end, for instance one can use</span>

<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.generate_ensemble(beta=1.719/0.797**4, update_u0=True, n_cfgs=5, ens_tag=&#39;imp_&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">MC</span><span class="o">.</span><span class="n">thermalize</span><span class="p">(</span><span class="n">n_therm</span><span class="p">,</span> <span class="n">fname_lambda</span><span class="o">=</span><span class="n">fname_lambda</span><span class="p">,</span> <span class="n">update_u0</span><span class="o">=</span><span class="n">update_u0</span><span class="p">,</span> <span class="n">eps_hit</span><span class="o">=</span><span class="n">eps_hit</span><span class="p">)</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">MC</span><span class="o">.</span><span class="n">gen_cfgs</span><span class="p">(</span><span class="n">n_skip</span><span class="o">=</span><span class="n">n_skip</span><span class="p">,</span> <span class="n">n_cfgs</span><span class="o">=</span><span class="n">n_cfgs</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fname_lambda</span><span class="o">=</span><span class="n">fname_lambda</span><span class="p">,</span> <span class="n">eps_hit</span><span class="o">=</span><span class="n">eps_hit</span><span class="p">)</span>
    <span class="n">generate_ensemble</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">expand_ensemble</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">beta</span><span class="o">=</span><span class="mf">5.5</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">load_ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_cfgs</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">n_skip</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">eps_hit</span><span class="o">=</span><span class="mf">0.24</span><span class="p">,</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function expands an existing ensemble by loading the last (saved) configuration</span>
<span class="sd">    and updating it to generate more gauge configurations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        similar to the parameters of :meth:`gauge_tools.examples.generate_ensemble` except that instead of `n_therm` and `update_u0`</span>
<span class="sd">        there is a new parameter called `load_ind` which is the index (`sweep_cntr`) of the gauge configuration</span>
<span class="sd">        that should be loaded to start with.</span>

<span class="sd">    Usage:</span>
<span class="sd">        (1) For generating (and saving) 15 more gauge configurations with Wilson action, one can use:: </span>

<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.expand_ensemble(load_ind=400, n_cfgs=15, ens_tag=&#39;W_&#39;)</span>

<span class="sd">            where it is assumed that the index (`ind_cfg`) of the last saved configurations is 400.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">load_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;load&amp;update&quot;</span><span class="p">,</span> <span class="n">load_fname</span><span class="o">=</span><span class="n">fname_lambda</span><span class="p">(</span><span class="n">load_ind</span><span class="p">),</span> <span class="n">load_ind</span><span class="o">=</span><span class="n">load_ind</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">MC</span><span class="o">.</span><span class="n">gen_cfgs</span><span class="p">(</span><span class="n">n_skip</span><span class="o">=</span><span class="n">n_skip</span><span class="p">,</span> <span class="n">n_cfgs</span><span class="o">=</span><span class="n">n_cfgs</span><span class="p">,</span> <span class="n">fname_lambda</span><span class="o">=</span><span class="n">fname_lambda</span><span class="p">,</span> <span class="n">eps_hit</span><span class="o">=</span><span class="n">eps_hit</span><span class="p">,</span> <span class="o">**</span><span class="n">load_kwargs</span><span class="p">)</span>
    <span class="n">expand_ensemble</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">measure_Wilson_loops</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes Monte Carlo averages of `a x a` and `a x 2a` Wilson loops</span>
<span class="sd">    exploiting the gauge configurations generated with functions :meth:`gauge_tools.examples.generate_ensemble` and :meth:`gauge_tools.examples.expand_ensemble`.</span>

<span class="sd">    This corresponds to the exercise on page 35 of the `lecture notes`_.</span>
<span class="sd">    For the exercise simply use::</span>
<span class="sd">        </span>
<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.measure_Wilson_loops(cfgs_list=range(200,1200,50), ens_tag=&#39;W_&#39;)</span>

<span class="sd">    The output looks like::</span>

<span class="sd">                Calculating averages of &#39;axa&#39; and &#39;ax2a&#39; Wilson loops:</span>
<span class="sd">                &#39;axa&#39;:0.49774(96), &#39;ax2a&#39;:0.2606(13)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list`` ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``cfgs_list`` (list):     a list of indices of configurations to be loaded and used for the Monte Carlo averages.</span>
<span class="sd">        - ``binsize``   (int):      bin size used for estimation of uncertainties. </span>
<span class="sd">        - ``ens_tag``   (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                                    for details see the parameters of function :meth:`gauge_tools.examples.generate_ensemble`. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">calc_a_a</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">U</span><span class="p">:</span> <span class="n">lat</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">avg_planar_loops</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">l1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">calc_a_2a</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">U</span><span class="p">:</span> <span class="n">lat</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">avg_planar_loops</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">l1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">U</span><span class="p">:</span> <span class="p">(</span><span class="n">calc_a_a</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">calc_a_2a</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating averages of &#39;axa&#39; and &#39;ax2a&#39; Wilson loops:&quot;</span><span class="p">)</span>
    <span class="n">T1</span>  <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">MC</span><span class="o">.</span><span class="n">eval_fn</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cfgs_list</span><span class="p">,</span> <span class="n">fname_lambda</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">avg_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;axa&#39;:</span><span class="si">{}</span><span class="s2">, &#39;ax2a&#39;:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">avg</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">),</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">(#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">measure_Wilson_loops</span><span class="o">.</span><span class="n">avg</span> <span class="o">=</span> <span class="n">avg</span>
    <span class="n">measure_Wilson_loops</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="c1">#==========================================================</span>
<span class="c1"># Example 2::</span>
<span class="c1">#   Compute the static potential using generated gauge configurations (in Example 1).</span>
<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">static_potential</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="n">max_R</span><span class="o">=</span><span class="mf">4.1</span><span class="p">,</span> <span class="n">max_T</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">smear_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">do_smear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smearing_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;u0&#39;</span><span class="p">:</span><span class="mf">0.84</span><span class="p">},</span>
        <span class="n">figname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the statice potential from Monte Carlo averages of `R times T` Wilson loops</span>
<span class="sd">    for different values of `R` and `T`.</span>

<span class="sd">    This corresponds to the exercise on page 37 of the `lecture notes`_.</span>
<span class="sd">    Here we smear the links first and then calculate the Wilson loops.</span>
<span class="sd">    One can simply disable the smearing by setting the option `do_smear=False`.</span>
<span class="sd">    Note that one can first run :meth:`gauge_tools.examples.ape_smear` to smear the links, save them, and then use them here.</span>
<span class="sd">    With a combination of the options `ens_tag` and `smear_tag` one can specify the links to be read,</span>
<span class="sd">    and with the option `do_smear` one can request an in-place smearing. In this case, one can control the</span>
<span class="sd">    smearing parameters by the `smearing_dict`. The latter one is used by default.</span>
<span class="sd">    For the exercise simply use::</span>
<span class="sd">       </span>
<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.static_potential(cfgs_list=range(200,1200,50), ens_tag=&#39;W_&#39;, figname=&#39;static_W_smear4.pdf&#39;)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list``     ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``cfgs_list``     (list):     a list of indices of configurations to be loaded for further calculations.</span>
<span class="sd">        - ``ens_tag``       (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                    for details see the parameters of :meth:`gauge_tools.examples.generate_ensemble`.</span>
<span class="sd">        - ``smear_tag``     (str):      useful if one is going to use the already saved smeared links;\</span>
<span class="sd">                    for details see the parameters of :meth:`gauge_tools.examples.ape_smear`.</span>
<span class="sd">                                        Ignore this if the smearing is going to be done in place.</span>
<span class="sd">        - ``do_smear``      (bool):     For smearing the links before calculating the Wilson loops;\</span>
<span class="sd">                                        the default value is `True`.</span>
<span class="sd">        - ``smearing_dict`` (dict)      a dictionary to control the smearing parameters;\      </span>
<span class="sd">                                        for available options see :meth:`gauge_tools.examples.ape_smear`.</span>
<span class="sd">        - ``max_R``         (float):    calculates the static potential for distances `\le max_R`.</span>
<span class="sd">        - ``max_T``         (int):      calculates the static potential for all times `\le max_T`.</span>
<span class="sd">        - ``figname``       (str):      if not an empyt string, creates a figure and saves it as a pdf in `figname`.</span>
<span class="sd"> </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="c1">#===============</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">smear_tag</span><span class="p">,</span> <span class="n">n_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">.p&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">smear_tag</span><span class="p">,</span> <span class="s1">&#39;Wilson_loops&#39;</span><span class="p">)</span>
    <span class="c1">#===============</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">range_T</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">max_T</span><span class="p">)</span>
    <span class="n">range_R</span><span class="p">,</span> <span class="n">spatial_paths</span> <span class="o">=</span> <span class="n">define_paths</span><span class="p">(</span><span class="n">max_R</span><span class="p">)</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">U</span><span class="p">:</span> <span class="p">[</span><span class="n">lat</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">avg_RxT_loops</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">path_R</span><span class="p">,</span> <span class="n">max_T</span><span class="p">)</span> <span class="k">for</span> <span class="n">path_R</span> <span class="ow">in</span> <span class="n">spatial_paths</span><span class="p">]</span>
    <span class="c1">#===============</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">U</span>  <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">GF</span><span class="o">.</span><span class="n">load_cfg</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">do_smear</span><span class="p">:</span>
            <span class="n">lat</span><span class="o">.</span><span class="n">smear</span><span class="o">.</span><span class="n">ape_smear</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="o">**</span><span class="n">smearing_dict</span><span class="p">)</span> <span class="c1"># the smearing is performed on `U`</span>
        <span class="n">dset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; RxT is evaluated for cfg=</span><span class="si">{}</span><span class="s2"> (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">range_R</span><span class="p">,</span> <span class="n">Wmean</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">W</span><span class="p">),</span> <span class="n">Wcov</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">evalcov</span><span class="p">(</span><span class="n">W</span><span class="p">)),</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_save</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">figname</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">PLOTS</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">W</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plot_static_potential</span><span class="p">(</span><span class="n">range_R</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">figname</span><span class="o">=</span><span class="n">figname</span><span class="p">)</span>
    <span class="n">static_potential</span><span class="o">.</span><span class="n">lat</span>  <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">define_paths</span><span class="p">(</span><span class="n">max_R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates all paths from the origin in the x-y-z volume subject to the following conditions:</span>
<span class="sd">            1) the total distance from the origin is not bigger than max_R.</span>
<span class="sd">            2) the number of steps in x-y or x-z or y-z planes are equal; e.g. (2,2,1) steps in (x,y,z) direction.</span>
<span class="sd">    Each path is shown by a tuple of at most three tuples e.g.</span>
<span class="sd">            ((0,s0),(1,s1),(2,s2))</span>
<span class="sd">    which means `s0,s1,s2` steps in the `0,1,2` directions, respectively. And</span>
<span class="sd">            ((0,s0),)</span>
<span class="sd">    means a path with only `s0` steps in the `0` direction.</span>
<span class="sd">    Here we group together the paths based on the cubic symmetry; e.g. (1,0,0) ~ (0,1,0) under pi/2 rotation of the x-y plane.</span>
<span class="sd">    We put the group into a list, and we organize the output as a list of lists, where each list contains a group of paths invariant</span>
<span class="sd">    under the cubic symmetry.</span>

<span class="sd">    Output:</span>
<span class="sd">        range_R         (list of dinstance):  the distance from the origin of the corresponding group in spatial_paths</span>
<span class="sd">        spatial_paths   (list of lists):      as discribed above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">range_R</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spatial_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Tpl</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
    <span class="c1">#=============</span>
    <span class="c1"># Firts group: the path is parallel to one of the axese.</span>
    <span class="n">rot_00a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">),),</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">),),</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">),)]</span>
    <span class="c1">#=============</span>
    <span class="c1"># second group: the path is in a plane (e.g x-y plane) with equal steps in each direction in the plane (e.g. x and y directions).</span>
    <span class="n">rot_0aa</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">)),</span>  <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">)),</span>  <span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">)),</span> \
                         <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">)),</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">)),</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">))]</span>
    <span class="c1">#=============</span>
    <span class="c1"># third group: all steps (in x, y, and z directions) are equal but can be postive or negative.</span>
    <span class="n">rot_aaa</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">)]</span>
    <span class="c1">#=============</span>
    <span class="c1"># fourth group: a part of the path in a plane (e.g x-y plane) has equal steps in each direction in the plane (e.g. x and y directions),</span>
    <span class="c1">#               but there is another part with steps not equal to...</span>
    <span class="n">rot_baa</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span>  <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">),</span>  <span class="n">Tpl</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> 
                           <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">),</span> 
                           <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">),</span> <span class="n">Tpl</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">)]</span> <span class="c1"># `a` is repeated twice and `a \neq b`.</span>
    <span class="c1">#=============</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">max_R</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nb">int</span><span class="p">((</span><span class="n">max_R</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">&gt;</span><span class="n">x</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nb">int</span><span class="p">((</span><span class="n">max_R</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z</span><span class="o">&gt;</span><span class="n">y</span><span class="p">:</span> <span class="k">continue</span>
                <span class="c1"># Note that  `z \le y \le x`, therefore either `z=y=x` or `z&lt;x`.</span>
                <span class="c1"># We want to average over all paths that are similar under a rotations by pi/2 degrees (cubic symmetry),</span>
                <span class="c1"># so we put each set of similar paths in a list so that we can take an average over them.</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>              <span class="c1"># x=y=z=0</span>
                <span class="k">elif</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">y</span> <span class="ow">and</span> <span class="n">y</span><span class="o">&gt;</span><span class="n">z</span><span class="p">:</span>
                    <span class="k">continue</span>              <span class="c1"># x&gt;y&gt;z</span>
                <span class="k">elif</span> <span class="n">x</span><span class="o">==</span><span class="n">y</span> <span class="ow">and</span> <span class="n">y</span><span class="o">==</span><span class="n">z</span><span class="p">:</span>
                    <span class="n">mylist</span> <span class="o">=</span> <span class="n">rot_aaa</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># x=y=z &gt; 0</span>
                <span class="k">elif</span> <span class="n">y</span><span class="o">==</span><span class="n">z</span> <span class="ow">and</span> <span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">mylist</span> <span class="o">=</span> <span class="n">rot_00a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># x &gt; y=z=0</span>
                <span class="k">elif</span> <span class="n">y</span><span class="o">==</span><span class="n">z</span> <span class="ow">and</span> <span class="n">z</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">mylist</span> <span class="o">=</span> <span class="n">rot_baa</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="c1"># x &gt; y=z &gt; 0</span>
                <span class="k">elif</span> <span class="n">y</span><span class="o">==</span><span class="n">x</span> <span class="ow">and</span> <span class="n">z</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">mylist</span> <span class="o">=</span> <span class="n">rot_0aa</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># x=y &gt; z=0</span>
                <span class="k">elif</span> <span class="n">y</span><span class="o">==</span><span class="n">x</span> <span class="ow">and</span> <span class="n">z</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">mylist</span> <span class="o">=</span> <span class="n">rot_baa</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="c1"># x=y &gt; z &gt; 0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c1"># the program won&#39;t reach here since `z \le y \le z`. </span>
                <span class="n">spatial_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span>
                <span class="n">range_R</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">range_R</span><span class="p">,</span> <span class="n">spatial_paths</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">plot_static_potential</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">figname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">T_snap</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">Y_mean</span> <span class="o">=</span> <span class="p">[</span><span class="n">V_r</span><span class="p">[</span><span class="n">T_snap</span><span class="p">]</span> <span class="k">for</span> <span class="n">V_r</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span>
    <span class="n">Y_sdev</span> <span class="o">=</span> <span class="p">[</span><span class="n">V_r</span><span class="p">[</span><span class="n">T_snap</span><span class="p">]</span> <span class="k">for</span> <span class="n">V_r</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">sdev</span><span class="p">(</span><span class="n">V</span><span class="p">)]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Y_mean</span><span class="p">,</span> <span class="n">Y_sdev</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$R/a$&quot;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$V(R)|_{</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">}$&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">T_snap</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">T_snap</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="mf">0.2</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">figname</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figname</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
    
<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">ape_smear</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
        <span class="n">n_smear</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eps_smear</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">12.</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="mf">0.84</span><span class="p">,</span> <span class="n">space_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">project_SU3</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">smear_tag</span><span class="o">=</span><span class="s1">&#39;smear4_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads the gauge configurations generated</span>
<span class="sd">    with functions :meth:`gauge_tools.examples.generate_ensemble` and :meth:`gauge_tools.examples.expand_ensemble`,</span>
<span class="sd">    smears them and saves them.</span>

<span class="sd">    This corresponds to the exercise on page 37 of the `lecture notes`_.</span>
<span class="sd">    For the exercise simply use::</span>

<span class="sd">                &gt;&gt;&gt; import gauge_tools as gt</span>
<span class="sd">                &gt;&gt;&gt; gt.examples.ape_smear(cfgs_list=range(200,1200,50), ens_tag=&#39;W_&#39;)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list``     ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``cfgs_list``     (list):     a list of indices of configurations to be loaded for smearing.</span>
<span class="sd">        - ``n_smear``       (int):      number of smearings.</span>
<span class="sd">        - ``eps_smear``     (float):    the `eps` used for smearing.</span>
<span class="sd">        - ``u0``            (float):    the `u0` used for tadpole improvement.</span>
<span class="sd">        - ``ens_tag``       (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                for details see the parameters of function :meth:`gauge_tools.examples.generate_ensemble`. </span>
<span class="sd">        - ``smear_tag``     (str):      a string used to construct a file name for saving a smeared gauge configuration;\</span>
<span class="sd">                                        see below for clarification. </span>
<span class="sd">        - ``space_only``    (bool):     the default value is `True` indicating that the smearing is going to be done only in spatial planes.\</span>
<span class="sd">                                        If set to `False`, the smearing will be performed for termpotal links too,\</span>
<span class="sd">                                        and also includes spatial-temporal planes.</span>
<span class="sd">        - ``project_SU3``   (bool):     the default value is `False` indicating that the smeared links are projected to SU(3) in the end.\</span>
<span class="sd">                                        Note that the algorithm used here works only for SU(3) gauges. </span>
<span class="sd">   </span>
<span class="sd">    A note on the file names:</span>
<span class="sd">        from the parameter `ens_tag` this function constructs two file names:</span>
<span class="sd">            - to load an existing configuration:</span>
<span class="sd">                    `fname_load = &quot;{}{}.npy&quot;.format(ens_tag, ind_cfg)`.</span>
<span class="sd">            - to save the smeared configuration:</span>
<span class="sd">                    `fname_save = &quot;{}{}{}.npy&quot;.format(ens_tag, smear_tag, ind_cfg)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">smear_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">smearing_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps_smear</span><span class="p">,</span> <span class="n">n_smear</span><span class="o">=</span><span class="n">n_smear</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="n">space_only</span><span class="o">=</span><span class="n">space_only</span><span class="p">,</span> <span class="n">project_SU3</span><span class="o">=</span><span class="n">project_SU3</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">U</span>  <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">GF</span><span class="o">.</span><span class="n">load_cfg</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">smear</span><span class="o">.</span><span class="n">ape_smear</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="o">**</span><span class="n">smearing_dict</span><span class="p">)</span> <span class="c1"># the smearing is performed on `U`</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname_save</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">),</span> <span class="n">U</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; cfg=</span><span class="si">{}</span><span class="s2"> is smeard and saved (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">ape_smear</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="c1">#==========================================================</span>
<span class="c1"># Example 3::</span>
<span class="c1">#   Fix the gauge of a configuration to the Landau gauge.</span>
<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">Landau_gauge</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
        <span class="n">max_itr</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">gaugefix_tol</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">fname_output</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gauge_tag</span><span class="o">=</span><span class="s1">&#39;Landau_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads the gauge configurations generated</span>
<span class="sd">    with functions :meth:`gauge_tools.examples.generate_ensemble` and :meth:`gauge_tools.examples.expand_ensemble`,</span>
<span class="sd">    fixes the gauge to the Landau gauge them and saves them.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list``     ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``cfgs_list``     (list):     a list of indices of configurations to be loaded for gauge fixing.</span>
<span class="sd">        - ``max_itr``       (int):      maximum number of iteration in gauge fixing.</span>
<span class="sd">        - ``gaugefix_tol``  (float):    the tolerance to hault the process of gauge fixing.</span>
<span class="sd">        - ``ens_tag``       (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                for details see the parameters of function :meth:`gauge_tools.examples.generate_ensemble`. </span>
<span class="sd">        - ``gauge_tag``     (str):      a string used to construct a file name for saving the gauge-fixed configuration;\</span>
<span class="sd">                                        see below for clarification. </span>
<span class="sd">        - ``fname_output``  (string):   if not an empty string, dumps the details of gauge fixing in `fname_output`.</span>

<span class="sd">    A note on the file names:</span>
<span class="sd">        from the parameter `ens_tag` this function constructs two file names:</span>
<span class="sd">            - to load an existing configuration:      </span>
<span class="sd">                    `fname_load = &quot;{}{}.npy&quot;.format(ens_tag, ind_cfg)`.</span>
<span class="sd">            - to save the gauge fixed configuration:</span>
<span class="sd">                    `fname_save = &quot;{}{}{}.npy&quot;.format(ens_tag, gauge_tag, ind_cfg)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">gauge_tag</span><span class="p">,</span> <span class="n">n_cfg</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">U</span>  <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">GF</span><span class="o">.</span><span class="n">load_cfg</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fname_output</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_output</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
                <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;#cfg = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">gaugefix</span><span class="o">.</span><span class="n">gaugefix_Landau</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">max_itr</span><span class="o">=</span><span class="n">max_itr</span><span class="p">,</span> <span class="n">gaugefix_tol</span><span class="o">=</span><span class="n">gaugefix_tol</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">fname_output</span><span class="p">)</span>
        <span class="c1"># Note that `U` is already updated inside the lat.smear.gradient_flow function</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname_save</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">),</span> <span class="n">U</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; cfg=</span><span class="si">{}</span><span class="s2"> gauge-fixed and saved (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">Landau_gauge</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="c1">#==========================================================</span>
<span class="c1"># Example 4::</span>
<span class="c1">#   Calculate quark propagagor</span>
<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">staggered_quark_prop</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
        <span class="n">src_type</span><span class="o">=</span><span class="s1">&#39;evenodd_wall&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">gauge_tag</span><span class="o">=</span><span class="s1">&#39;Landau_&#39;</span><span class="p">,</span>
        <span class="n">prop_tag</span><span class="o">=</span><span class="s1">&#39;eoprop_&#39;</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">do_smear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smearing_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;u0&#39;</span><span class="p">:</span><span class="mf">0.84</span><span class="p">},</span> <span class="n">tadpole</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculating the propagator of a staggered quark.</span>
<span class="sd">    Here we smear the links before calculating the quark propagator.</span>
<span class="sd">    One can simply disable the smearing by setting the option `do_smear=False`.</span>
<span class="sd">    The smearing parameters can be changed by manipulating `smearing_dict`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - ``size_list`` ([int]*4):  a list of 4 positive integers specifying the lattice size in `[x,y,z,t]` directions.</span>
<span class="sd">        - ``cfgs_list`` (list):     a list of indices of configurations to be loaded for further calculations.</span>
<span class="sd">        - ``src_type``  (str):      a string indicating the source type; the available types are\</span>
<span class="sd">                                    &#39;point_src&#39;, &#39;corner_wall&#39;, &#39;even_wall&#39;, and &#39;evenodd_wall&#39;, and &#39;evenminusodd_wall&#39;.</span>
<span class="sd">        - ``t0``        (int):      the time slice of the source.</span>
<span class="sd">        - ``color_list`` (list):    the color charge of the source; for now the code only accepts one charge, e.g. [0].</span>
<span class="sd">        - ``ens_tag``   (str):      a unique tag (label) describing the ensemble:\</span>
<span class="sd">                                    for details see the parameters of function :meth:`gauge_tools.examples.generate_ensemble`. </span>
<span class="sd">        - ``gauge_tag`` (str):      a string used to construct a file name for laoding the gauge-fixed configuration;\</span>
<span class="sd">                                    see below for clarification. </span>
<span class="sd">        - ``prop_tag``  (str):      a string used to construct a file name for saving the propagators;\</span>
<span class="sd">                                    see below for clarification. </span>
<span class="sd">        - ``mass``      (int):      the mass of the quark.</span>
<span class="sd">        - ``do_smear``  (bool):     For smearing the links before calculating the quark propagator;\</span>
<span class="sd">                                    the default value is `True`.</span>
<span class="sd">        - ``smearing_dict`` (dict): a dictionary to control the smearing parameters;\      </span>
<span class="sd">                                    for available options see :meth:`gauge_tools.examples.ape_smear`.</span>
<span class="sd">        - ``tadpole``   (bool):     if `True`, performs a tadpole improvement on the links befor calculating the propagator;\</span>
<span class="sd">                                    the default value is `False`.</span>
<span class="sd">   </span>
<span class="sd">    A note on the file names:</span>
<span class="sd">        from the parameter `ens_tag` this function constructs two file names:</span>
<span class="sd">            - to load an existing configuration:\      </span>
<span class="sd">                    `fname_load = &quot;{}{}{}.npy&quot;.format(ens_tag, gauge_tag, ind_cfg)`.</span>
<span class="sd">            - to saved the propagator:\</span>
<span class="sd">                    `fname_save = &quot;{}{}m{}_{}.npy&quot;.format(ens_tag, prop_tag, mass, ind_cfg)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">gauge_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">m</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">prop_tag</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">lat</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">set_source</span><span class="p">(</span><span class="n">src_type</span><span class="p">,</span><span class="n">t0</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span><span class="n">color_list</span><span class="o">=</span><span class="n">color_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">T1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">U</span>  <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">GF</span><span class="o">.</span><span class="n">load_cfg</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">do_smear</span><span class="p">:</span>
            <span class="n">lat</span><span class="o">.</span><span class="n">smear</span><span class="o">.</span><span class="n">ape_smear</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="o">**</span><span class="n">smearing_dict</span><span class="p">)</span> <span class="c1"># the smearing is performed on `U`</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">calc_propagator</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">n_restart</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tadpole</span><span class="o">=</span><span class="n">tadpole</span><span class="p">)</span>
        <span class="n">lat</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">save_propagator</span><span class="p">(</span><span class="n">fname_save</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; cfg=</span><span class="si">{}</span><span class="s2"> quark propagator is calculated and saved for mass=</span><span class="si">{}</span><span class="s2"> (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">staggered_quark_prop</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">avg_quark_prop</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
        <span class="n">src_type</span><span class="o">=</span><span class="s1">&#39;evenodd_wall&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">prop_tag</span><span class="o">=</span><span class="s1">&#39;eoprop_&#39;</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">figname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads the propagators calculated in :meth:`gauge_tools.examples.staggered_quark_prop`</span>
<span class="sd">    and averages them. Most key word arguments are similar to those of :meth:`gauge_tools.examples.staggered_quark_prop`,</span>
<span class="sd">    except for ``figname``, which if not an empyt string, is a signal to create a figure and save it as a pdf in `figname`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">m</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">prop_tag</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">m</span><span class="si">{}</span><span class="s2">_avg.p&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">prop_tag</span><span class="p">,</span> <span class="n">mass</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">props_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">props_projected</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">prop_v_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">),</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">props_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prop_v_field</span><span class="p">)</span>
        <span class="n">props_projected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">gt</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">propagator</span><span class="o">.</span><span class="n">ks_project_spatialmom</span><span class="p">(</span><span class="n">prop_v_field</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">props_proj_gvar</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">props_projected</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">props_proj_gvar</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">evalcov</span><span class="p">(</span><span class="n">props_proj_gvar</span><span class="p">)),</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_save</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
    <span class="n">avg_quark_prop</span><span class="o">.</span><span class="n">props_list</span> <span class="o">=</span> <span class="n">props_list</span>
    <span class="n">avg_quark_prop</span><span class="o">.</span><span class="n">props_proj_gvar</span> <span class="o">=</span> <span class="n">props_proj_gvar</span>
    <span class="n">avg_quark_prop</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>
    <span class="k">if</span> <span class="n">figname</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">PLOTS</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">props_proj_gvar</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">props_proj_gvar</span><span class="p">)),</span> <span class="n">gv</span><span class="o">.</span><span class="n">sdev</span><span class="p">(</span><span class="n">props_proj_gvar</span><span class="p">),</span><span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;interacting&#39;</span><span class="p">)</span>
        <span class="n">free_theory</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="n">src_type</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="n">mass</span><span class="p">,</span> <span class="n">color_list</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span> <span class="n">print_</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;qaurk propagator in free and interacting theory&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figname</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free_theory</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="n">src_type</span><span class="o">=</span><span class="s2">&quot;evenodd_wall&quot;</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">print_</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">quark_src</span><span class="p">(</span><span class="n">src_type</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
    <span class="n">src</span><span class="o">.</span><span class="n">build_src</span><span class="p">(</span><span class="n">color_list</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">propagator</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="n">free</span><span class="o">.</span><span class="n">build_free_prop</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_</span><span class="p">:</span>
        <span class="n">gt</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">propagator</span><span class="o">.</span><span class="n">print_vector_field</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">v_field</span><span class="p">,</span><span class="n">n_blocks</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">free_projected</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">quark</span><span class="o">.</span><span class="n">propagator</span><span class="o">.</span><span class="n">ks_project_spatialmom</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">v_field</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">PLOTS</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">free_projected</span><span class="p">),</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Free theory&#39;</span><span class="p">)</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">gradient_flow</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;W&#39;</span><span class="p">,</span>
                    <span class="n">max_flowtime</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">save_field</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fname_output</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">figname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function uses the gradient flow method to smear the gauge fields,</span>
<span class="sd">    and calculates the lattice spacing. The topological charge is also calculated but not investigated yet.</span>

<span class="sd">    ***NOTE*** The materials related to the gradeint flow are NOT complete yet.</span>
<span class="sd">    This function will probably change in the next versions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_load</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="n">fname_save</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">_flowtime</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">n_cfg</span><span class="p">,</span> <span class="n">max_flowtime</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span> <span class="c1"># we do not use tadpole improvement</span>
    <span class="n">a_dset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n_cfg</span> <span class="ow">in</span> <span class="n">cfgs_list</span><span class="p">:</span>
        <span class="n">T1</span><span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">GF</span><span class="o">.</span><span class="n">load_cfg</span><span class="p">(</span><span class="n">fname_load</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fname_output</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname_output</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
                <span class="n">fw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;#cfg = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">))</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">smear</span><span class="o">.</span><span class="n">gradient_flow</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">actn</span><span class="o">.</span><span class="n">calc_staples</span><span class="p">,</span> <span class="n">max_flowtime</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">fname_output</span><span class="p">)</span>
        <span class="c1"># Note that `U` is already updated inside the lat.smear.gradient_flow function</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">save_field</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fname_save</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">),</span> <span class="n">U</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; cfg=</span><span class="si">{:.6g}</span><span class="s2"> is calculated at flowtime </span><span class="si">{}</span><span class="s2"> and saved; yeilds a=</span><span class="si">{}</span><span class="s2"> fm (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_cfg</span><span class="p">,</span><span class="n">max_flowtime</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; a=</span><span class="si">{:.6g}</span><span class="s2"> fm</span><span class="se">\t</span><span class="s2">for cfg=</span><span class="si">{}</span><span class="s2"> (#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n_cfg</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
        <span class="n">a_dset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">a_dset</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; average: a = </span><span class="si">{}</span><span class="s2"> fm&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">gradient_flow</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>
    <span class="n">gradient_flow</span><span class="o">.</span><span class="n">mydict</span> <span class="o">=</span> <span class="n">mydict</span>

<span class="c1">#==========================================================</span>
<span class="k">def</span> <span class="nf">measure_polyakov_loops</span><span class="p">(</span><span class="n">size_list</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cfgs_list</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1200</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="n">binsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">ens_tag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function calculate the polyakov loops on the given configurations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fname_lambda</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">ind_cfg</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens_tag</span><span class="p">,</span> <span class="n">ind_cfg</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">gauge_tools</span> <span class="k">as</span> <span class="nn">gt</span>
    <span class="n">lat</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="o">*</span><span class="n">size_list</span><span class="p">,</span> <span class="o">**</span><span class="n">lat_kwargs</span><span class="p">)</span>
    <span class="n">fn</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">U</span><span class="p">:</span> <span class="n">lat</span><span class="o">.</span><span class="n">meas</span><span class="o">.</span><span class="n">avg_polyakov_loops</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating averages of polyakov loops:&quot;</span><span class="p">)</span>
    <span class="n">T1</span>  <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">MC</span><span class="o">.</span><span class="n">eval_fn</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cfgs_list</span><span class="p">,</span> <span class="n">fname_lambda</span><span class="p">,</span> <span class="n">binsize</span><span class="o">=</span><span class="n">binsize</span><span class="p">,</span> <span class="n">avg_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;polyakov-loops&gt;: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">avg</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">),</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">(#TIME = </span><span class="si">{:.4g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">T1</span><span class="p">))</span>
    <span class="n">measure_polyakov_loops</span><span class="o">.</span><span class="n">avg</span> <span class="o">=</span> <span class="n">avg</span>
    <span class="n">measure_polyakov_loops</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lat</span>

<span class="c1">#==========================================================</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">gauge_tools</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Examples</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gtcore.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Main</span> <span class="pre">objects</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lib.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Libraries</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Utilities</span></code></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../gauge_tools.html">gauge_tools</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Javad Komijani.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>